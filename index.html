<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steeplechase Learning Platform v4</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #27ae60; /* Green */
            --warning: #f39c12; /* Amber */
            --danger: #c0392b; /* Red */
            --light: #ecf0f1;
            --track-color: #8da35e;
        }

        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #eef2f3; margin: 0; padding: 20px; display: flex; flex-direction: column; height: 100vh; }
        
        /* LAYOUT */
        #game-container { display: flex; flex: 1; gap: 20px; max-width: 1600px; margin: 0 auto; width: 100%; }
        #sidebar { flex: 0 0 350px; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 20px; }
        #main-view { flex: 1; display: flex; flex-direction: column; gap: 20px; }

        /* TRACK VISUALS */
        #track-container { flex: 1; background: var(--track-color); border-radius: 12px; border: 8px solid #5d6d3d; position: relative; overflow: hidden; padding: 10px;}
        .track-path {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 Columns */
            grid-template-rows: repeat(5, 1fr);    /* 5 Rows = 50 Tiles */
            gap: 6px;
            height: 100%;
            box-sizing: border-box;
        }
        
        .tile {
            background: rgba(255,255,255,0.8);
            border-radius: 4px;
            border: 2px solid rgba(0,0,0,0.1);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #555;
            font-weight: bold;
        }

        /* OBSTACLE STYLES */
        .obstacle { border-width: 4px; }
        .obs-green { border-color: var(--accent); background: #e8f8f5; }
        .obs-amber { border-color: var(--warning); background: #fef9e7; }
        .obs-red { border-color: var(--danger); background: #fdedec; }
        
        .tile-icon { font-size: 20px; position: absolute; top: 2px; right: 2px; }
        .tile-cost { position: absolute; bottom: 2px; right: 2px; font-size: 10px; background: #333; color: white; padding: 2px 4px; border-radius: 4px; }

        /* PLAYERS */
        .token {
            width: 32px; height: 32px; border-radius: 50%; border: 3px solid white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4); position: absolute; transition: all 0.5s ease;
            z-index: 10; display: flex; justify-content: center; align-items: center; font-size: 18px;
        }
        .token-p1 { background: #3498db; } 
        
        /* CONTROLS */
        .btn { border: none; padding: 15px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; transition: transform 0.1s; width: 100%; margin-bottom: 10px; color: white; font-size: 16px;}
        .btn:active { transform: scale(0.98); }
        .btn-action { background: var(--primary); border-left: 5px solid #1a252f; text-align: left; }
        .btn-green { background: var(--accent); }
        .btn-red { background: var(--danger); }
        .btn-warning { background: var(--warning); color: #333; }
        
        .hidden { display: none !important; }

        /* MODALS */
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 12px; width: 600px; max-width: 90%; text-align: center; position: relative; }
        #timer-bar { height: 10px; background: #ddd; width: 100%; margin: 20px 0; border-radius: 5px; overflow: hidden; }
        #timer-fill { height: 100%; background: var(--accent); width: 100%; transition: width 0.1s linear; }
        .answer-btn { background: white; border: 2px solid var(--primary); color: var(--primary); margin: 10px 0; text-align: left; transition: all 0.2s; }
        .answer-btn:hover { background: var(--light); }
        
        /* UI ELEMENTS */
        .card { background: var(--light); padding: 15px; border-radius: 8px; border-left: 5px solid var(--primary); }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .resource-badge { display: inline-block; padding: 5px 10px; border-radius: 15px; color: white; font-weight: bold; font-size: 14px; margin-right: 5px; }
        .res-lift { background-color: #9b59b6; } 
        .res-reach { background-color: #e67e22; } 
        
        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 10px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* NEW TIMER DISPLAY */
        #turn-timer-display {
            font-size: 1.2em; font-weight: bold; color: var(--danger); text-align: center; margin-bottom: 10px;
            background: rgba(255,255,255,0.5); padding: 5px; border-radius: 4px;
        }

    </style>
</head>
<body>

    <div id="start-screen" style="position:fixed; top:0; left:0; width:100%; height:100%; background:white; z-index:200; display:flex; flex-direction:column; justify-content:center; align-items:center; gap:20px;">
        <h1>üèá Steeplechase Learning Platform</h1>
        
        <div id="loading-area" style="text-align: center;">
            <div class="loader"></div>
            <p>Loading Question Deck...</p>
        </div>

        <div id="selection-area" class="hidden" style="width: 400px; text-align: center;">
            <h3 style="color: var(--accent);">System Ready</h3>
            <p>Choose Your Jockey Strategy</p>
            <div style="display:flex; gap:10px; justify-content: center; margin-top: 20px;">
                <button class="btn btn-green" onclick="startGame('Easy')">Easy<br><span style="font-size:0.8em">The Tactician</span></button>
                <button class="btn btn-warning" onclick="startGame('Medium')">Medium<br><span style="font-size:0.8em">The Veteran</span></button>
                <button class="btn btn-red" onclick="startGame('Hard')">Hard<br><span style="font-size:0.8em">The Daredevil</span></button>
            </div>
            <p id="deck-status" style="margin-top: 20px; font-size: 0.8em; color: #7f8c8d;"></p>
        </div>
    </div>

    <div id="game-container" class="hidden">
        <div id="sidebar">
            <h2>Player Dashboard</h2>
            
            <div class="card">
                <div class="stat-row"><span>Jockey:</span> <strong id="ui-jockey">Loading...</strong></div>
                <div class="stat-row"><span>Lap:</span> <strong id="ui-lap">1 / 2</strong></div>
            </div>

            <div class="card">
                <h3>Resources</h3>
                <div style="margin-bottom: 10px;">
                    <span class="resource-badge res-lift">LIFT: <span id="res-lift-count">0</span></span>
                    <span class="resource-badge res-reach">REACH: <span id="res-reach-count">0</span></span>
                </div>
                <p style="font-size: 0.8em; color: #666;">Use Lift for Fences üöß | Reach for Water üåä</p>
            </div>

            <div id="action-panel">
                <h3>Actions</h3>
                <div id="turn-timer-display" class="hidden">‚è±Ô∏è 60s</div>
                <div id="controls-area"></div>
            </div>
        </div>

        <div id="main-view">
            <div id="track-container">
                <div class="track-path" id="track-grid">
                    </div>
            </div>
        </div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div class="modal-content">
            <h2 id="modal-title">Question</h2>
            <div id="timer-bar"><div id="timer-fill"></div></div>
            <p id="modal-text" style="font-size: 1.2em; margin-bottom: 20px;">Question...</p>
            <div id="modal-options" style="display: flex; flex-direction: column;">
                </div>
        </div>
    </div>

    <script>
        // --- DATA & CONFIG ---
        const TRACK_LENGTH = 50; 
        const TOTAL_LAPS = 2;
        const CSV_FILENAME = 'A_Level_Law_Question_Deck.csv'; 
        const ACTION_TIME_LIMIT = 60; // 60 Seconds for the Action Phase

        let QUESTION_DB = [
            { id: 1, difficulty: 'Easy', text: "DEMO: What is meant by law?", correct: "Rules enforced by state", d1: "Moral opinions", d2: "Social customs" },
            { id: 2, difficulty: 'Easy', text: "DEMO: Standard of proof in criminal cases?", correct: "Beyond reasonable doubt", d1: "Balance of probabilities", d2: "Absolute certainty" },
            { id: 3, difficulty: 'Hard', text: "DEMO: Donoghue v Stevenson established duty of care for:", correct: "Manufacturers to consumers", d1: "Employers to employees", d2: "Doctors to patients" }
        ];

        const OBSTACLES = {
            6:  { name: "Low Fence",    type: "LIFT",  severity: 1, cost: 1 },
            13: { name: "Small Ditch",  type: "REACH", severity: 1, cost: 1 },
            20: { name: "Medium Gate",  type: "LIFT",  severity: 2, cost: 2 },
            27: { name: "Open Water",   type: "REACH", severity: 2, cost: 2 },
            34: { name: "Double Hedge", type: "LIFT",  severity: 2, cost: 2 },
            41: { name: "The Grand Canyon", type: "REACH", severity: 3, cost: 3 }, 
            48: { name: "The High Wall",    type: "LIFT",  severity: 3, cost: 3 }, 
        };

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.lap = 1;
                this.player = { pos: 0, lift: 0, reach: 0, jockey: null };
                this.actionTimer = null;
                this.timeLeft = 0;
                this.currentObstacleContext = null; // Store context for auto-move
            }

            init(jockeyType) {
                this.player.jockey = new Jockey(jockeyType);
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                document.getElementById('ui-jockey').innerText = `${this.player.jockey.name} (${jockeyType})`;
                this.renderBoard();
                this.startTurn();
            }

            startTurn() {
                this.stopActionTimer(); // Clean up previous
                updateUI();
                renderControls("WAITING", "Answer the question to unlock dice...");
                
                const q = this.getQuestion();
                showQuestionModal(q, this.player.jockey.timer, (success) => {
                    if (success) {
                        this.startActionPhase();
                    } else {
                        this.applyPenalty("Incorrect or Timeout!");
                    }
                });
            }

            startActionPhase() {
                // Start the 60s Timer
                this.startActionTimer();
                renderControls("CHOOSE_STANCE");
            }

            startActionTimer() {
                this.stopActionTimer();
                this.timeLeft = ACTION_TIME_LIMIT;
                const display = document.getElementById('turn-timer-display');
                display.classList.remove('hidden');
                display.innerText = `‚è±Ô∏è ${this.timeLeft}s`;

                this.actionTimer = setInterval(() => {
                    this.timeLeft--;
                    display.innerText = `‚è±Ô∏è ${this.timeLeft}s`;
                    
                    if (this.timeLeft <= 0) {
                        this.handleActionTimeout();
                    }
                }, 1000);
            }

            stopActionTimer() {
                if (this.actionTimer) clearInterval(this.actionTimer);
                document.getElementById('turn-timer-display').classList.add('hidden');
            }

            handleActionTimeout() {
                this.stopActionTimer();
                // AUTO-MOVE LOGIC based on current state check
                // We infer state from what controls are currently rendered or internal flags
                
                // If we are waiting for STANCE (controls has executeAction buttons)
                const controls = document.getElementById('controls-area').innerHTML;
                
                if (controls.includes('CHOOSE_STANCE') || controls.includes('SPRINT')) {
                    // Default to CANTER (Safe)
                    alert("‚è≥ Time's Up! Auto-selecting CANTER.");
                    this.executeAction('CANTER');
                } 
                else if (this.currentObstacleContext) {
                    // We are stuck at an obstacle. Default to RISK.
                    alert("‚è≥ Time's Up! Forced to RISK IT.");
                    const ctx = this.currentObstacleContext;
                    this.resolveObstacle('RISK', 0, null, ctx.riskTarget);
                }
                else {
                    // We are likely at the RESULT screen waiting for Next Turn
                    // Or stuck in a weird state. Just force next turn.
                    this.startTurn();
                }
            }

            getQuestion() {
                const diff = this.player.jockey.difficulty; 
                let pool = QUESTION_DB.filter(q => q.difficulty === diff);
                if (pool.length === 0) pool = QUESTION_DB; 
                return pool[Math.floor(Math.random() * pool.length)];
            }

            executeAction(actionType) {
                const r1 = Math.ceil(Math.random() * 6);
                const r2 = Math.ceil(Math.random() * 6);
                let move = 0;
                let gainedResource = null;

                if (actionType === 'SPRINT') {
                    move = r1 + r2; 
                } else if (actionType === 'GATHER') {
                    this.gainResource(this.player.jockey.getBias(r1));
                    this.gainResource(this.player.jockey.getBias(r2));
                    renderControls("RESULT", `üéí GATHERED! Rolled ${r1} & ${r2}. Gain 2 Resources. (No Move)`);
                    return; 
                } else if (actionType === 'CANTER') {
                    move = r1;
                    gainedResource = this.player.jockey.getBias(r2);
                    this.gainResource(gainedResource);
                }

                if (this.player.jockey.difficulty === 'Hard' && r1 <= 2 && actionType !== 'GATHER') {
                    renderControls("RESULT", `‚ùå STUMBLE! Hard Jockey rolled a ${r1}. No Movement.`);
                    return; 
                }

                this.movePlayer(move, r1, r2, gainedResource);
            }

            movePlayer(steps, d1, d2, res) {
                const start = this.player.pos;
                let target = start + steps;
                let msg = `üé≤ Rolled ${d1} & ${d2}. Moving ${steps}.`;
                if(res) msg += ` +1 ${res}.`;

                for(let i = start + 1; i <= target; i++) {
                    let tileIdx = i % TRACK_LENGTH;
                    if (tileIdx === 0) tileIdx = TRACK_LENGTH; 

                    if (OBSTACLES[tileIdx]) {
                        this.player.pos = i - 1; 
                        this.renderBoard();
                        this.triggerObstacleEncounter(OBSTACLES[tileIdx], target - i);
                        return; 
                    }
                }

                this.player.pos = target;
                this.renderBoard();
                this.checkLap();
                renderControls("RESULT", msg);
            }

            triggerObstacleEncounter(obs) {
                const needed = obs.type === 'LIFT' ? this.player.lift : this.player.reach;
                const riskTarget = obs.severity + 2; 

                // Store context for Timer Auto-Move
                this.currentObstacleContext = { obs: obs, riskTarget: riskTarget };

                let html = `<h3>üõë ${obs.name}</h3>`;
                html += `<p>Severity: Level ${obs.severity} (${obs.type})</p>`;
                html += `<p>Cost: <b>${obs.cost} ${obs.type}</b>. You have: ${needed}.</p>`;
                
                let buttons = '';
                if (needed >= obs.cost) {
                    buttons += `<button class="btn btn-green" onclick="game.resolveObstacle('PAY', ${obs.cost}, '${obs.type}')">PAY & PASS (Safe)</button>`;
                }
                
                buttons += `<button class="btn btn-red" onclick="game.resolveObstacle('RISK', 0, null, ${riskTarget})">RISK IT (Roll ${riskTarget}+)</button>`;
                
                document.getElementById('controls-area').innerHTML = html + buttons;
            }

            resolveObstacle(method, cost, type, target) {
                this.currentObstacleContext = null; // Clear context

                if (method === 'PAY') {
                    if (type === 'LIFT') this.player.lift -= cost;
                    else this.player.reach -= cost;
                    this.player.pos += 1; 
                    renderControls("RESULT", "‚úÖ PAID! Cleared safely.");
                } else {
                    const roll = Math.ceil(Math.random() * 6);
                    if (roll >= target) {
                        this.player.pos += 1; 
                        renderControls("RESULT", `üé≤ SUCCESS! Rolled ${roll} (Needed ${target}+).`);
                    } else {
                        const penalty = 2; 
                        this.player.pos = Math.max(0, this.player.pos - penalty);
                        renderControls("RESULT", `üí• CRASH! Rolled ${roll}. Knocked back ${penalty} spaces.`);
                    }
                }
                updateUI();
                this.renderBoard();
            }

            applyPenalty(reason) {
                this.player.pos += 1; 
                const r = Math.random() > 0.5 ? "LIFT" : "REACH";
                this.gainResource(r);
                this.checkLap();
                
                // Show Penalty Result, THEN wait for Next Turn (using RESULT state)
                renderControls("RESULT", `‚ùå ${reason}<br>Penalty: Crawl 1 space. Gained 1 ${r}.`);
                this.renderBoard();
            }

            gainResource(type) {
                if(type === 'LIFT') this.player.lift++;
                if(type === 'REACH') this.player.reach++;
                updateUI();
            }

            checkLap() {
                const distance = TRACK_LENGTH * this.lap;
                if (this.player.pos >= distance) {
                    if (this.lap === TOTAL_LAPS) {
                        alert("üéâ FINISH LINE! YOU WIN!");
                        location.reload();
                    } else {
                        alert("üèÅ LAP 1 COMPLETE! Resources Reset.");
                        this.player.lift = 0;
                        this.player.reach = 0;
                        this.lap++;
                    }
                }
            }

            renderBoard() {
                const grid = document.getElementById('track-grid');
                grid.innerHTML = '';
                for(let i=1; i<=TRACK_LENGTH; i++) {
                    const div = document.createElement('div');
                    div.className = 'tile';
                    div.innerText = i;
                    
                    if(OBSTACLES[i]) {
                        div.classList.add('obstacle');
                        if(OBSTACLES[i].severity === 1) div.classList.add('obs-green');
                        if(OBSTACLES[i].severity === 2) div.classList.add('obs-amber');
                        if(OBSTACLES[i].severity === 3) div.classList.add('obs-red');
                        const icon = OBSTACLES[i].type === 'LIFT' ? 'üöß' : 'üåä';
                        div.innerHTML += `<div class="tile-icon">${icon}</div><div class="tile-cost">${OBSTACLES[i].cost}</div>`;
                    }

                    let visualPos = this.player.pos % TRACK_LENGTH;
                    if(visualPos === 0 && this.player.pos > 0) visualPos = 50; 

                    if (i === visualPos) {
                        const token = document.createElement('div');
                        token.className = 'token token-p1';
                        token.innerText = 'üèá';
                        div.appendChild(token);
                    }
                    grid.appendChild(div);
                }
            }
        }

        class Jockey {
            constructor(type) {
                this.difficulty = type;
                if (type === 'Easy') {
                    this.name = "The Tactician";
                    this.timer = 15;
                    this.bias = [1,2,3,4]; 
                } else if (type === 'Medium') {
                    this.name = "The Veteran";
                    this.timer = 20;
                    this.bias = [1,2,3]; 
                } else {
                    this.name = "The Daredevil";
                    this.timer = 25;
                    this.bias = [1,2]; 
                }
            }
            getBias(roll) { return this.bias.includes(roll) ? "LIFT" : "REACH"; }
        }

        const game = new Game();

        function startGame(type) { game.init(type); }
        function updateUI() {
            document.getElementById('res-lift-count').innerText = game.player.lift;
            document.getElementById('res-reach-count').innerText = game.player.reach;
            document.getElementById('ui-lap').innerText = `${game.lap} / ${TOTAL_LAPS}`;
        }

        function renderControls(state, msg = "") {
            const area = document.getElementById('controls-area');
            area.innerHTML = '';
            
            if (state === "WAITING") {
                area.innerHTML = `<p>${msg}</p>`;
            } 
            else if (state === "CHOOSE_STANCE") {
                area.innerHTML = `
                    <p style="color:var(--accent);"><b>‚úÖ Answer Correct!</b><br>Choose your Strategy:</p>
                    <button class="btn btn-action" onclick="game.executeAction('SPRINT')">‚ö° SPRINT (Max Speed)</button>
                    <button class="btn btn-action" onclick="game.executeAction('GATHER')">üéí GATHER (Max Resources)</button>
                    <button class="btn btn-warning" onclick="game.executeAction('CANTER')">‚öñÔ∏è CANTER (Balanced)</button>
                `;
            } 
            else if (state === "RESULT") {
                // MANUAL NEXT TURN BUTTON
                area.innerHTML = `
                    <p>${msg}</p>
                    <button class="btn btn-action" style="background:#34495e; margin-top:20px;" onclick="game.startTurn()">‚û°Ô∏è NEXT TURN</button>
                `;
            }
        }

        let timerInterval;
        function showQuestionModal(qObj, seconds, callback) {
            const modal = document.getElementById('modal-overlay');
            const fill = document.getElementById('timer-fill');
            modal.classList.remove('hidden');
            
            document.getElementById('modal-title').innerText = `${qObj.difficulty} Question`;
            document.getElementById('modal-text').innerText = qObj.text;
            
            const opts = [
                { txt: qObj.correct, isCorrect: true },
                { txt: qObj.d1, isCorrect: false },
                { txt: qObj.d2, isCorrect: false }
            ].sort(() => Math.random() - 0.5);

            const optContainer = document.getElementById('modal-options');
            optContainer.innerHTML = '';
            
            if (timerInterval) clearInterval(timerInterval);

            opts.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'btn answer-btn';
                btn.innerText = opt.txt;
                btn.onclick = () => {
                    clearInterval(timerInterval);
                    modal.classList.add('hidden');
                    callback(opt.isCorrect); 
                };
                optContainer.appendChild(btn);
            });

            fill.style.width = '100%';
            fill.style.transition = 'none'; 
            setTimeout(() => {
                fill.style.transition = `width ${seconds}s linear`;
                fill.style.width = '0%';
            }, 10);

            let timeLeft = seconds;
            timerInterval = setInterval(() => {
                timeLeft--;
                if(timeLeft <= 0) {
                    clearInterval(timerInterval);
                    modal.classList.add('hidden');
                    callback(false); 
                }
            }, 1000);
        }

        window.onload = function() {
            fetch(CSV_FILENAME)
                .then(response => {
                    if (!response.ok) throw new Error("File not found");
                    return response.text();
                })
                .then(text => {
                    const rows = text.split('\n').slice(1);
                    const parsed = [];
                    rows.forEach((row, index) => {
                        const cols = row.split(','); 
                        if(cols.length >= 6) {
                            parsed.push({
                                id: index,
                                difficulty: cols[1].trim(),
                                text: cols[2].trim(),
                                correct: cols[3].trim(),
                                d1: cols[4].trim(),
                                d2: cols[5].trim()
                            });
                        }
                    });
                    if (parsed.length > 0) {
                        QUESTION_DB = parsed;
                        document.getElementById('deck-status').innerText = `‚úÖ Loaded ${parsed.length} questions from ${CSV_FILENAME}`;
                        document.getElementById('deck-status').style.color = 'green';
                    }
                })
                .catch(err => {
                    console.warn("Using Demo Data.", err);
                    document.getElementById('deck-status').innerText = `‚ö†Ô∏è Using internal Demo Data.`;
                    document.getElementById('deck-status').style.color = 'orange';
                })
                .finally(() => {
                    document.getElementById('loading-area').classList.add('hidden');
                    document.getElementById('selection-area').classList.remove('hidden');
                });
        };
    </script>
</body>
</html>